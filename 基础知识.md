## 一、数组
**定义**  
使用连续的存储空间，存储一组相同类型数据的线性表数据结构

**优点**  
- 可随机访问，查询快 
- 内存占用相对小

**缺点**  
- 插入、删除效率低


---
## 二、链表
**定义**  
以一组任意存储单元（可连续，可不连续），存储一组相同数据类型数据的线性表数据结构

**优点**  
- 存储空间可随时申请，不需要提前分配
- 插入、删除等效率比数组高

**缺点**  
- 需要占用额外的内存空间存储指针


---
## 三、队列/堆栈
### 队列
**定义**  
先进先出，允许一端插入，另一端删除的线性数据结构

> 队头：允许删除的一端  
> 队尾：允许插入的一端

#### 优先队列
在队列中，元素被赋予优先级，当访问队列元素时，具有最高优先级的元素最先删除
> 最高优先级先出而不是先进先出

### 栈
**定义**  
后进先出，只允许一端插入、删除的线性数据结构

> 栈顶：允许插入、删除的一端  
> 栈底：另一端

> 入栈: 插入操作  
> 出栈: 删除操作

#### 单调栈
在栈的「先进后出」规则基础上，要求「从 栈顶 到 栈底 的元素是单调递增（或者单调递减）

> 单调递增栈: 从栈顶到栈底一直递增  
> 单调递减栈: 从栈顶到栈底一直递减



---
## 三、哈希表
**定义**  
也叫散列表，根据关键key值，直接访问元素的数据结构

> 哈希表通过「键 key 」和「映射函数 Hash(key) 」计算出对应的「值 value」  
映射函数叫做「哈希函数（散列函数）」  
存放记录的数组叫做「哈希表（散列表）」

> - 哈希函数应该易于计算，并且尽量使计算出来的索引值均匀分布
> - 哈希函数计算得到的哈希值是一个固定长度的输出值
> - 如果 Hash(key1) 不等于 Hash(key2)，那么 key1、key2 一定不相等
> - 如果 Hash(key1) 等于 Hash(key2)，那么 key1、key2 可能相等，也可能不相等(会发生哈希碰撞)


### 常用哈希函数方法
- 直接定址法
- 除留余数法
- 平方取中法
- 基数转换法

###  哈希冲突
不同的关键字通过同一个哈希函数可能得到同一哈希地址

**解决方法**  
- 开放地址法
- 链地址法


---
## 四、字符串  
由零个或多个字符组成的有限序列  
> - 字符串名称：字符串定义中的 s 就是字符串的名称。  
> - 字符串的值：
 组成的字符序列就是字符串的值，一般用双引号括起来。
> - 字符变量：字符串每一个位置上的元素
> - 字符串的长度：字符串中字符的数目  
> - 空串：零个字符构成的串
> - 子串：字符串中任意个连续的字符组成的子序列称为该字符串的 「子串（Substring）」;起始于位置为 0、长度为 k 的子串称为 「前缀（Prefix）」。而终止于位置 n - 1、长度为 k 的子串称为 「后缀（Suffix）」。  
> - 主串：包含子串的字符串相应的称为 「主串」

**字符串大小比较**   
依次比较组成字符串的字符之间的「字符编码」，有大为大，全部相等才相等；不够长度看长度。
> A: 65   a:97

**单模式串匹配**  

KMP算法  
对于给定文本串 T 与模式串 p，当发现文本串 T 的某个字符与模式串 p 不匹配的时候，可以利用匹配失败后的信息，尽量减少模式串与文本串的匹配次数，避免文本串位置的回退，以达到快速匹配的目的

**多模式串匹配**   

**字典树**  
像字典一样的树存储字符串，用于字符串快速检索的多叉树
> - 根节点不包含字符，除根节点外，每个节点都只包含一个字符。  
> - 从根节点到某一节点，路径上经过的字符串连接起来，就是该节点对应的字符串。  
> - 每个节点的所有子节点包含的字符串都不相同。  

![字典树](/img/Trie.png)

---
## 五、树
![字典树](/img/tree.png)  

由 n >= 0个节点与节点之间的关系组成的有限集合。  
当 n = 0 时称为空树  
当 n > 0 时称为非空树  

> - 树的节点: 由一个数据元素和若干个指向其的子树的树的分支构成
> - 节点的度: 节点子树数量
> - 树的度: 树中节点度的最大度数
> - 分支节点: 度不为0的节点
> - 叶子节点: 度为0的节点

> - 节点的层:从根节点为第1层，根的子节点为第2层，依次类推
> - 数的高(深)度: 所有节点的最大层数
> - 路径: 树中两个节点之间经过的节点序列
> - 路径长度: 两个节点路径经过的边数

### 树的分类  
有序树: 节点的各个子树从左到右有序，不可互换  
无序树: 节点的各个子树可互换位置，无序


### 二叉树  
树中各个节点的度不大于2的有序树（左子树、右子树）    


#### 满二叉树  
- 所有节点都存在左子树和右子树
- 所有叶子节点都在同一层  
(就是所有节点都有两个叉，并且子节点都是2)  


#### 完全二叉树  
- 叶子节点只能出现在最下面两层
- 并且最下层的叶子节点都依次排列在该层最左边的位置上
(层高差不超过1，并且叶子节点都靠左)  


#### 二叉搜索树  
- 任意节点左子树所有节点的值都小于它的根节点  
- 任意节点右子树所有节点的值都大于它的根节点  
- 任意节点左、右子树也是二叉搜索树  
![二叉搜索树](/img/Binary-Search-Tree.png) 


##### 平衡二叉搜索树  
- 是二叉搜索树
- 层高差不超过1  
![平衡二叉搜索树](/img/AVL_Tree.png)  


##### 线段树  
![线段树](/img/Segment-Tree.png)   

用于在区间上进行信息统计,基于分治思想的二叉树  
> - 线段树的每个节点都代表一个区间
> - 线段树具有唯一的根节点，代表的区间是整个统计范围，比如 [1, n]
> - 线段树的每个叶子节点都代表一个长度为 1 的单位区间 [x, x]
> - 对于每个内部节点 [left, right]，它的左子节点是 [left, mid]，右子节点是 [mid + 1, right]。其中 mid = (left + right) / 2（向下取整）

- 根节点的编号为 0
- 节点（非叶子节点）的下标为 i，那么左子节点下标为 2 * i + 1，右子节点下标为 2 * i + 2
- 某二叉树节点（非根节点）的下标为 i，那么其父节点下标为 (i - 1) // 2，// 表示整除。


##### 并查集  
用于处理一些不交集的合并及查询问题的一种树型数据结构

- 合并：将两个集合合并成一个集合
- 查找：确定某个元素属于哪个集合

**路径压缩**  
在从底向上查找根节点过程中，如果此时访问的节点不是根节点，则把这个节点尽量向上移动一下，从而减少树的层树

- 隔代压缩:
    把当前节点指向它的父亲节点的父亲节点
- 完全压缩:
    把被查询的节点到根节点的路径上的所有节点的父节点设置为根节点

**按秩合并**  
每次合并操作时，都把「秩」较小的树根节点指向「秩」较大的树根节点  

- 按深度合并:
    每次合并操作时，把「深度」较小的树根节点指向「深度」较大的树根节点
- 按大小合并:
    每次合并操作时，都把「集合节点个数」较少的树根节点指向「集合节点个数」较大的树根节点  

一般使用「隔代压缩」，不使用「按秩合并」，代码简单易写，又能得到不错的性能  


---

## 六、图  
![图](/img/Graph.png)  

由顶点的非空有限集合V（由 n > 0个顶点组成）与边的集合E （顶点之间的关系）构成的结构。其形式化定义为 G = (V, E)

- 顶点： 图中的数据元素
- 边： 两个顶点的之间的关联关系 e = <u, v>    


**分类**  
- 无向图：图中每条边都没有指向性
- 有向图：图中每条边都有指向性

> 完全无向图:所有顶点之间互通且都无向
> 完全有向图:多有顶点之间互通且都有向

![图](/img/Complete-Graph.png)  


- 顶点的度：与该顶点相关联的边数 TD(vi)
 > 顶点的出度：从该顶点出发的边数 OD(vi)  
 > 顶点的入度：以该顶点终止的边数 ID(vi)  
 > 顶点的度 = 入度 + 出度  


**路径**  
从一个顶点A经过一系列的顶点和边能到达B，则经过的顶点序列称为A、B的一条路径

**环**  
如果一条路径的起终点相同，称为环  

- 无环图：图中不存在环路
- 有环图：图中至少存在一条环路  
> 有向无环图（DAG）： 有向图中不存在环路

**简单路径**  
顶点序列中顶点不重复出现的路径称为简单路径  

![图](/img/Circular-Graph.png)   


### 连通图和非连通图  
- 连通无向图： 无向图中任意两个顶点都是连通的(a到b有路径)  
- 非连通无向图： 无向图中至少存在一对顶点之间不存在任何路径  

![图](/img/liantong.png)   

- 连通子图： 无向图的子图是连通的，该子图称为连通子图  
- 极大连通子图： 无向图的一个连通子图，并且不存在**包含它**的更大的连通子图
- 连通分量：无向图的一个极大连通子图称为该图的连通分量  

> 也就是说无向图的极大连通子图就是无向图的连通分量  


- 强连通有向图： 有向图中任意两个顶点之间是连通的（a到b，b到a都有路径）
- 非强连通有向图：有向图中至少存在一对顶点不存在任何路径  
> 跟无向图的区别就是连通性，有向图要求两顶点双向互通，无向图有路径就行，叫法不一样，有向图加了个“强”字  

- 强连通子图： 有向图的子图是连通的，该子图称为强连通子图  
- 极大强连通子图： 有向图的一个强连通子图，并且不存在**包含它**的更大的强连通子图
- 强连通分量：有向图的一个极大强连通子图称为该图的强连通分量  

  

**带权图**  
图中的每条边都带权  
网络： 带权的连通无向图称为网络  


**图的遍历**  
- 深度优先搜索
- 广度优先搜索  

---
## 七、基础算法
1. 枚举算法  
2. 递归算法
3. 分治算法
4. 回溯算法
5. 贪心算法
6. 位运算

---
## 八、动态规划  
